Часть 1. Балансировщик нагрузки

Основной функционал:
- [x]  Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080).
- [x] При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения. Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

Распределение запросов:
- [x] Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
- [x] Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы).

Параллелизм и конкурентность:
- [x] Обеспечить одновременную обработку нескольких запросов с использованием горутин.
- [ ]   Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

Обработка ошибок:
- [x] Реализовать обработку ошибок при обращении к бэкендам.
- [x] Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

Логирование:
- [x] Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

Конфигурация:
- [x] Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки.
- [x] Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

Часть 2. Реализация Rate-Limiting
Функциональные требования:
Реализация алгоритма Token Bucket:
- [x] Каждому клиенту (IP или API-ключ) выделяется отдельный bucket токенов.
- [x] Настройки bucket: количество токенов (емкость), скорость пополнения.
- [x] Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.

Гранулярное ограничение:
- [x] Отслеживать состояние каждого клиента (IP/API-ключ)
- [x] Поддерживать возможность настройки разных лимитов для разных клиентов.
- [x] Настройки для разных клиентов можно сохранять в базе данных

Автоматическое пополнение токенов:
- [x] Использовать time.Ticker для периодического пополнения токенов в buckets.
- [x] Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).

Конкурентность:
- [x] Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
- [ ] Обеспечить минимальные блокировки для максимизации производительности.

Требуется подготовить README с описанием сборки и запуска проекта.
Будет здорово, если:
    Архитектура проекта будет модульной: разделите код на логически обособленные пакеты (например, для логики распределения, работы с конфигурацией и реализации HTTP-сервера).
    Приветствуется чистота кода, понятное и подробное комментирование, а также применение интерфейсов для упрощения замены реализаций.
    Оценка задания будет проводиться не только на основе реализованного функционала, но и на основе качества кода (структурирование, тестируемость, документация).
    Напишите Dockerfile и docker-compose.yml для развертывания сервиса и БД
    Добавите интеграционные тесты с использованием go test -bench=. -race.
    Пример нагрузки через Apache Bench (ab -n 5000 -c 1000 http://localhost:8080/).

Дополнительные пункты для размышления

Поддержка нескольких алгоритмов распределения:

    Помимо round-robin, реализовать или предусмотреть возможность использования алгоритмов «least connections» или случайного распределения запросов.

Здоровье бэкендов (Health Checks):

- [x] Добавить механизм периодических проверок состояния каждого бэкенд-сервера.
- [x] При обнаружении недоступного сервера временно исключать его из пула, а при восстановлении работы возвращать обратно.

Graceful Shutdown:
- [x] Реализовать корректное завершение работы балансировщика (обработка сигнала SIGINT или SIGTERM), чтобы завершить обработку текущих запросов без потери данных.

CRUD для управления клиентами:
- [x] API для добавления/удаления клиентов (IP/API-ключей) и настройки их лимитов.
    Пример эндпоинта: POST /clients { "client_id": "user1", "capacity": 100, "rate_per_sec": 10 }

Персистентность:
- [x] Сохранять состояние клиентов (текущие токены, настройки) в БД или файле.
- [x] Использовать конфигурационный файл для дефолтных лимитов.

Обработка ошибок:
- [x] Возвращать структурированные JSON-ошибки с кодом и описанием. Пример: { "code": 429, "message": "Rate limit exceeded" }
